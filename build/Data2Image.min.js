(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/sign"), __esModule: true };
},{"core-js/library/fn/math/sign":5}],2:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":6}],3:[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],4:[function(require,module,exports){
"use strict";

var _Object$defineProperty = require("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      _Object$defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":2}],5:[function(require,module,exports){
require('../../modules/es6.math.sign');
module.exports = require('../../modules/$.core').Math.sign;
},{"../../modules/$.core":8,"../../modules/es6.math.sign":14}],6:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":12}],7:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],8:[function(require,module,exports){
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],9:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":7}],10:[function(require,module,exports){
var global    = require('./$.global')
  , core      = require('./$.core')
  , ctx       = require('./$.ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
},{"./$.core":8,"./$.ctx":9,"./$.global":11}],11:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],12:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],13:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],14:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./$.export');

$export($export.S, 'Math', {sign: require('./$.math-sign')});
},{"./$.export":10,"./$.math-sign":13}],15:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Math$sign = require('babel-runtime/core-js/math/sign')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _common = require('./common');

var ranges = {
	number: [-16581375, 16581375],
	color: [0, 255],
	rgb: [0, 255],
	vec2: [0, 1],
	vec3: [0, 1],
	vec4: [0, 1]
};

var Data2Image = (function () {
	function Data2Image(options) {
		_classCallCheck(this, Data2Image);

		this.options = options || {};
		this.elements = [];
		this.instances = 0;
	}

	_createClass(Data2Image, [{
		key: 'addElement',
		value: function addElement(name, type, populate_callback) {
			this.elements.push({ name: name, type: type, fill: populate_callback, id: this.elements.length });
		}
	}, {
		key: 'getTotalElements',
		value: function getTotalElements() {
			return this.elements.length;
		}
	}, {
		key: 'setTotalInstances',
		value: function setTotalInstances(number) {
			this.instances = number;
		}
	}, {
		key: 'getTotalInstances',
		value: function getTotalInstances() {
			return this.instances;
		}
	}, {
		key: 'getTableSize',
		value: function getTableSize() {
			return [this.getTotalInstances(), this.getTotalElements()];
		}
	}, {
		key: 'generate',
		value: function generate() {
			var width = this.getTotalInstances();
			var height = this.getTotalElements();

			var canvas = document.createElement("canvas");
			canvas.width = width;
			canvas.height = height;

			var ctx = canvas.getContext('2d');
			var imageData = ctx.createImageData(width, height);
			var data = imageData.data;
			var index = undefined,
			    y = undefined,
			    x = undefined,
			    r = undefined,
			    i = undefined;
			var channels = 4;
			var value = undefined;

			for (y = 0; y < height; y++) {
				for (x = 0; x < width; x++) {
					index = (y * width + x) * channels;
					var v = this.elements[y].fill(x, this.elements[y]);
					value = encodeValue(v, this.elements[y].type);
					for (i = 0; i < channels; i++) {
						data[index + i] = value[i];
					}
				}
			}
			ctx.putImageData(imageData, 0, 0);
			return canvas;
		}
	}, {
		key: 'version',
		value: function version() {
			return '0.0.1';
		}
	}]);

	return Data2Image;
})();

exports['default'] = Data2Image;

function getRangeFor(type) {
	return ranges[type];
}

function encodeValue(_x, _x2) {
	var _again = true;

	_function: while (_again) {
		var value = _x,
		    type = _x2;
		_again = false;

		if (value < getRangeFor(type)[0] || value > getRangeFor(type)[1]) {
			console.log('Value', value, 'of type', type, 'is out of range', getRangeFor(type), 'will be clamped to', value);
			value = (0, _common.clamp)(value, getRangeFor(type)[0], getRangeFor(type)[1]);
		}

		if (type === 'number') {
			var s = _Math$sign(value);
			var d = (0, _common.getDecimals)(value) + 1.;
			var uint = Math.abs(value) * Math.pow(10, d); // transform the number into unsigned integers
			var pres = 244 + d * s;
			// console.log("Value:",value,"S:",s,"D:",d,"Uint:",uint,"Press:",pres);
			return [Math.floor(uint % 255), Math.floor(uint / 255) % 255, Math.floor(uint / (255 * 255)), pres];
		} else if (type === 'position') {
			// Values have to be normalized [-1,1]
			_x = value;
			_x2 = 'vec2';
			_again = true;
			s = d = uint = pres = undefined;
			continue _function;
		} else if (type === 'vec2') {
			var x = value[0];
			var y = value[1];
			x = .5 + x * .5;;
			y = .5 + y * .5;
			x *= 65025;
			y *= 65025;
			return [Math.floor(x % 255), Math.floor(x / 255) % 255, Math.floor(y % 255), Math.floor(y / 255) % 255];
		} else if (type === 'color') {
			// Values between [0,255]
			_x = value;
			_x2 = 'rgb';
			_again = true;
			s = d = uint = pres = x = y = undefined;
			continue _function;
		} else if (type === 'rgb' || type === 'vec3' || type === 'vec4') {
			return [Math.floor(value[0] / getRangeFor(type)[1] * 255), Math.floor(value[1] / getRangeFor(type)[1] * 255), Math.floor(value[2] / getRangeFor(type)[1] * 255), value[3] ? Math.floor(value[3] / 255) : 255];
		}
	}
}

window.Data2Image = Data2Image;
module.exports = exports['default'];

},{"./common":16,"babel-runtime/core-js/math/sign":1,"babel-runtime/helpers/class-call-check":3,"babel-runtime/helpers/create-class":4}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.clamp = clamp;
exports.getDecimals = getDecimals;

function clamp(value, min, max) {
	// return Math.max(min, Math.min(max, value)); // faster??
	return value > max ? max : value < min ? min : value;
}

function getDecimals(number) {
	var match = (Math.abs(number) + '').match(/\d+\.(\d+)/);
	return match ? match[1].length : 0;
}

},{}]},{},[15])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hdGgvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3MtY2FsbC1jaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlLWNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXRoL3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmN0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmV4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQubWF0aC1zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCIvVXNlcnMvcGF0cmljaW8vRGVza3RvcC9kYXRhMmltYWdlL3NyYy9EYXRhMkltYWdlLmpzIiwiL1VzZXJzL3BhdHJpY2lvL0Rlc2t0b3AvZGF0YTJpbWFnZS9zcmMvY29t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QyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQSxDQUFFLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN4RCxRQUFPLEtBQUssR0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztDQUNsQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbWF0aC9zaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KSgpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk1hdGguc2lnbjsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKXtcbiAgcmV0dXJuICQuc2V0RGVzYyhpdCwga2V5LCBkZXNjKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMS4yLjYnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuLyQuY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKHBhcmFtKXtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBDID8gbmV3IEMocGFyYW0pIDogQyhwYXJhbSk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIGlmKElTX1BST1RPKShleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KSlba2V5XSA9IG91dDtcbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgLy8gd3JhcFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgJE9iamVjdCA9IE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcbiAgZ2V0UHJvdG86ICAgJE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgaXNFbnVtOiAgICAge30ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBzZXREZXNjOiAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICBzZXREZXNjczogICAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXG4gIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcbiAgZ2V0TmFtZXM6ICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICBnZXRTeW1ib2xzOiAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgZWFjaDogICAgICAgW10uZm9yRWFjaFxufTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59OyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7c2lnbjogcmVxdWlyZSgnLi8kLm1hdGgtc2lnbicpfSk7IiwiaW1wb3J0IHsgY2xhbXAsIGdldERlY2ltYWxzIH0gZnJvbSAnLi9jb21tb24nO1xuXG52YXIgcmFuZ2VzID0ge1xuXHRudW1iZXI6IFstMTY1ODEzNzUsMTY1ODEzNzVdLFxuXHRjb2xvcjogWzAsIDI1NV0sXG5cdHJnYjogWzAsIDI1NV0sXG5cdHZlYzI6IFswLCAxXSxcblx0dmVjMzogWzAsIDFdLFxuXHR2ZWM0OiBbMCwgMV0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhMkltYWdlIHtcblx0Y29uc3RydWN0b3IgKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcblx0XHR0aGlzLmluc3RhbmNlcyA9IDA7XG5cdH1cblxuXHRhZGRFbGVtZW50KG5hbWUsIHR5cGUsIHBvcHVsYXRlX2NhbGxiYWNrKSB7XG5cdFx0dGhpcy5lbGVtZW50cy5wdXNoKHsgbmFtZTogbmFtZSwgdHlwZTogdHlwZSwgZmlsbDogcG9wdWxhdGVfY2FsbGJhY2ssIGlkOiB0aGlzLmVsZW1lbnRzLmxlbmd0aCB9KTtcblx0fVxuXG5cdGdldFRvdGFsRWxlbWVudHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHR9XG5cblx0c2V0VG90YWxJbnN0YW5jZXMobnVtYmVyKSB7XG5cdFx0dGhpcy5pbnN0YW5jZXMgPSBudW1iZXI7XG5cdH1cblxuXHRnZXRUb3RhbEluc3RhbmNlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZXM7XG5cdH1cblxuXHRnZXRUYWJsZVNpemUoKSB7XG5cdFx0cmV0dXJuIFt0aGlzLmdldFRvdGFsSW5zdGFuY2VzKCksIHRoaXMuZ2V0VG90YWxFbGVtZW50cygpXTtcblx0fVxuXG5cdGdlbmVyYXRlICgpIHtcblx0XHRsZXQgd2lkdGggPSB0aGlzLmdldFRvdGFsSW5zdGFuY2VzKCk7XG5cdFx0bGV0IGhlaWdodCA9IHRoaXMuZ2V0VG90YWxFbGVtZW50cygpO1xuXG5cdFx0bGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdCAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcblx0ICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdCAgICBsZXQgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcblx0ICAgIGxldCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdCAgICBsZXQgaW5kZXgsIHksIHgsIHIsIGk7XHQgICAgXHRcblx0ICAgIGxldCBjaGFubmVscyA9IDQ7XG5cdCAgICBsZXQgdmFsdWU7XG5cblx0ICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuXHQgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gKHkqd2lkdGgreCkqY2hhbm5lbHM7XG5cdCAgICAgICAgICAgIGxldCB2ID0gdGhpcy5lbGVtZW50c1t5XS5maWxsKHgsIHRoaXMuZWxlbWVudHNbeV0pO1xuXHRcdFx0XHR2YWx1ZSA9IGVuY29kZVZhbHVlKHYsIHRoaXMuZWxlbWVudHNbeV0udHlwZSk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjaGFubmVsczsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YVtpbmRleCtpXSA9IHZhbHVlW2ldO1xuXHRcdFx0XHR9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXHQgICAgcmV0dXJuIGNhbnZhcztcblx0fVxuXG5cdHZlcnNpb24gKCkge1xuICAgICAgICByZXR1cm4gJzAuMC4xJztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlRm9yKHR5cGUpIHtcblx0cmV0dXJuIHJhbmdlc1t0eXBlXTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG5cdGlmICh2YWx1ZSA8IGdldFJhbmdlRm9yKHR5cGUpWzBdIHx8IHZhbHVlID4gZ2V0UmFuZ2VGb3IodHlwZSlbMV0pIHtcblx0XHRjb25zb2xlLmxvZygnVmFsdWUnLHZhbHVlLCdvZiB0eXBlJywgdHlwZSwnaXMgb3V0IG9mIHJhbmdlJyxnZXRSYW5nZUZvcih0eXBlKSwnd2lsbCBiZSBjbGFtcGVkIHRvJyx2YWx1ZSk7XG5cdFx0dmFsdWUgPSBjbGFtcCh2YWx1ZSxnZXRSYW5nZUZvcih0eXBlKVswXSxnZXRSYW5nZUZvcih0eXBlKVsxXSk7XG5cdH1cblxuXHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRsZXQgcyA9IE1hdGguc2lnbih2YWx1ZSk7XG5cdFx0bGV0IGQgPSBnZXREZWNpbWFscyh2YWx1ZSkrMS47XG5cdFx0bGV0IHVpbnQgPSBNYXRoLmFicyh2YWx1ZSkgKiBNYXRoLnBvdygxMCxkKTtcdC8vIHRyYW5zZm9ybSB0aGUgbnVtYmVyIGludG8gdW5zaWduZWQgaW50ZWdlcnNcblx0XHRsZXQgcHJlcyA9IDI0NCArIGQqcztcblx0XHQvLyBjb25zb2xlLmxvZyhcIlZhbHVlOlwiLHZhbHVlLFwiUzpcIixzLFwiRDpcIixkLFwiVWludDpcIix1aW50LFwiUHJlc3M6XCIscHJlcyk7XG5cdCAgICByZXR1cm4gW1xuXHQgICAgICAgIE1hdGguZmxvb3IodWludCUyNTUpLFxuXHQgICAgICAgIE1hdGguZmxvb3IodWludC8yNTUpJTI1NSxcblx0ICAgICAgICBNYXRoLmZsb29yKHVpbnQvKDI1NSoyNTUpKSxcblx0ICAgICAgICBwcmVzXG5cdCAgICBdO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdwb3NpdGlvbicpIHtcblx0XHQvLyBWYWx1ZXMgaGF2ZSB0byBiZSBub3JtYWxpemVkIFstMSwxXVxuXHRcdHJldHVybiBlbmNvZGVWYWx1ZSh2YWx1ZSwgJ3ZlYzInKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAndmVjMicpIHtcdFx0XHRcdFxuXHRcdGxldCB4ID0gdmFsdWVbMF07XG5cdFx0bGV0IHkgPSB2YWx1ZVsxXTtcblx0XHR4ID0gLjUreCouNTs7XG5cdFx0eSA9IC41K3kqLjU7XG5cdFx0eCAqPSA2NTAyNTtcblx0XHR5ICo9IDY1MDI1O1xuXHRcdHJldHVybiBbXG5cdFx0XHRNYXRoLmZsb29yKHglMjU1KSxcblx0ICAgICAgICBNYXRoLmZsb29yKHgvMjU1KSUyNTUsXG5cdCAgICAgICAgTWF0aC5mbG9vcih5JTI1NSksXG5cdCAgICAgICAgTWF0aC5mbG9vcih5LzI1NSklMjU1XG5cdCAgICBdO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdjb2xvcicpIHtcblx0XHQvLyBWYWx1ZXMgYmV0d2VlbiBbMCwyNTVdXG5cdFx0cmV0dXJuIGVuY29kZVZhbHVlKHZhbHVlLCAncmdiJyk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ3JnYicgfHwgdHlwZSA9PT0gJ3ZlYzMnIHx8IHR5cGUgPT09ICd2ZWM0Jykge1xuXHRcdHJldHVybiBbXG5cdCAgICAgICAgTWF0aC5mbG9vcigodmFsdWVbMF0vZ2V0UmFuZ2VGb3IodHlwZSlbMV0pKjI1NSksXG5cdCAgICAgICAgTWF0aC5mbG9vcigodmFsdWVbMV0vZ2V0UmFuZ2VGb3IodHlwZSlbMV0pKjI1NSksXG5cdCAgICAgICAgTWF0aC5mbG9vcigodmFsdWVbMl0vZ2V0UmFuZ2VGb3IodHlwZSlbMV0pKjI1NSksXG5cdCAgICAgICAgdmFsdWVbM10/IE1hdGguZmxvb3IodmFsdWVbM10vMjU1KTogMjU1XG5cdCAgICBdO1xuXHR9XG59XG5cbndpbmRvdy5EYXRhMkltYWdlID0gRGF0YTJJbWFnZTsiLCJleHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG5cdC8vIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTsgLy8gZmFzdGVyPz9cblx0cmV0dXJuICh2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVjaW1hbHMobnVtYmVyKSB7XG5cdGxldCBtYXRjaCA9IChNYXRoLmFicyhudW1iZXIpICsgJycpLm1hdGNoKC9cXGQrXFwuKFxcZCspLyk7XG5cdHJldHVybiBtYXRjaD8gbWF0Y2hbMV0ubGVuZ3RoIDogMDtcbn0iXX0=
