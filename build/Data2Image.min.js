(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/sign"), __esModule: true };
},{"core-js/library/fn/math/sign":6}],2:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/epsilon"), __esModule: true };
},{"core-js/library/fn/number/epsilon":7}],3:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":8}],4:[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],5:[function(require,module,exports){
"use strict";

var _Object$defineProperty = require("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      _Object$defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":3}],6:[function(require,module,exports){
require('../../modules/es6.math.sign');
module.exports = require('../../modules/$.core').Math.sign;
},{"../../modules/$.core":10,"../../modules/es6.math.sign":16}],7:[function(require,module,exports){
require('../../modules/es6.number.epsilon');
module.exports = Math.pow(2, -52);
},{"../../modules/es6.number.epsilon":17}],8:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":14}],9:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],10:[function(require,module,exports){
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],11:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":9}],12:[function(require,module,exports){
var global    = require('./$.global')
  , core      = require('./$.core')
  , ctx       = require('./$.ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
},{"./$.core":10,"./$.ctx":11,"./$.global":13}],13:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],14:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],15:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],16:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./$.export');

$export($export.S, 'Math', {sign: require('./$.math-sign')});
},{"./$.export":12,"./$.math-sign":15}],17:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./$.export');

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});
},{"./$.export":12}],18:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _encode = require('./encode');

var _decode = require('./decode');

// Class

var Data2Image = (function () {
	function Data2Image(options) {
		_classCallCheck(this, Data2Image);

		this.options = options || {};
		this.elements = [];
		this.instances = 0;
	}

	_createClass(Data2Image, [{
		key: 'addElement',
		value: function addElement(name, type, populate_callback, range) {
			this.elements.push({ id: this.elements.length, name: name, type: type, range: range, fill: populate_callback });
		}
	}, {
		key: 'getTotalElements',
		value: function getTotalElements() {
			return this.elements.length;
		}
	}, {
		key: 'setTotalInstances',
		value: function setTotalInstances(number) {
			this.instances = number;
		}
	}, {
		key: 'getTotalInstances',
		value: function getTotalInstances() {
			return this.instances;
		}
	}, {
		key: 'getTableSize',
		value: function getTableSize() {
			return [this.getTotalInstances(), this.getTotalElements()];
		}
	}, {
		key: 'generate',
		value: function generate() {
			var width = this.getTotalInstances();
			var height = this.getTotalElements();

			var canvas = document.createElement("canvas");
			canvas.width = width;
			canvas.height = height;

			var ctx = canvas.getContext('2d');
			var imageData = ctx.createImageData(width, height);
			var data = imageData.data;
			var index = undefined,
			    y = undefined,
			    x = undefined,
			    r = undefined,
			    i = undefined;
			var channels = 4;
			var value = undefined;

			for (y = 0; y < height; y++) {
				for (x = 0; x < width; x++) {
					index = (y * width + x) * channels;
					var v = this.elements[y].fill(x, this.elements[y]);
					value = (0, _encode.encodeValue)(v, this.elements[y].type, this.elements[y].range);
					for (i = 0; i < channels; i++) {
						data[index + i] = value[i];
					}
				}
			}
			ctx.putImageData(imageData, 0, 0);
			return canvas;
		}
	}, {
		key: 'version',
		value: function version() {
			return '0.0.2';
		}
	}]);

	return Data2Image;
})();

exports['default'] = Data2Image;

window.Data2Image = Data2Image;
module.exports = exports['default'];

},{"./decode":20,"./encode":21,"babel-runtime/helpers/class-call-check":4,"babel-runtime/helpers/create-class":5}],19:[function(require,module,exports){
'use strict';

var _Number$EPSILON = require('babel-runtime/core-js/number/epsilon')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.clamp = clamp;
exports.map = map;
exports.decimals = decimals;

function clamp(value, min, max) {
    // return Math.max(min, Math.min(max, value)); // faster??
    return value > max ? max : value < min ? min : value;
}

function map(value, inputMin, inputMax, outputMin, outputMax) {
    var clamp = arguments.length <= 5 || arguments[5] === undefined ? true : arguments[5];

    if (Math.abs(inputMin - inputMax) < _Number$EPSILON) {
        return outputMin;
    } else {
        var outVal = (value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin;
        if (clamp) {
            if (outputMax < outputMin) {
                if (outVal < outputMax) {
                    outVal = outputMax;
                } else if (outVal > outputMin) {
                    outVal = outputMin;
                }
            } else {
                if (outVal > outputMax) {
                    outVal = outputMax;
                } else if (outVal < outputMin) {
                    outVal = outputMin;
                }
            }
        }
        return outVal;
    }
}

function decimals(number) {
    var match = (Math.abs(number) + '').match(/\d+\.(\d+)/);
    return match ? match[1].length : 0;
}

},{"babel-runtime/core-js/number/epsilon":2}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.getDecodeFunctionFor = getDecodeFunctionFor;

var _encode = require('./encode');

var common = '\nvec2 getCoord(vec2 res, float col, float row) {\n    return fract(vec2(col,row+.5)/res);\n}' + '\n';

var uint = common + '\nfloat getUInt(sampler2D tex, vec2 res, float col, float row) {\n    highp vec4 value = texture2D(tex, coord);\n    return (value.x*255.)+(value.y*65025.)+(value.z*16581375.);\n}';

var ufloat = common + '\nfloat getUFloat(sampler2D tex, vec2 res, float col, float row) {\n    highp vec4 value = texture2D(tex, coord);\n    return ((value.x*255.)+(value.y*65025.)+(value.z*16581375.))/16581375.;\n}';

var position = common + '\nvec2 getPosition(sampler2D tex, vec2 res, float col, float row) {\n    vec2 coord = getCoord(res, col, row);\n    highp vec4 value = texture2D(tex, coord);\n    float x = (value.r*255+value.g*65025.)/65025.;\n    float y = (value.b*255.+value.a*65025.)/65025.;\n    return vec2(x,y);\n}' + '\n';

var color = common + '\nvec4 getColor(sampler2D tex, vec2 res, float col, float row) {\n    vec2 coord = getCoord(res, col, row);\n    return texture2D(tex, coord);\n}' + '\n';

var decode = {
    uint: uint,
    int: uint + '\nfloat getInt(sampler2D tex, vec2 res, float col, float row) {\n    return getUInt(tex,res,col,row)-8290688.;\n}',
    ufloat: ufloat,
    float: ufloat + '\nfloat getUFloat(sampler2D tex, vec2 res, float col, float row) {\n    return (getUFloat(tex,res,col,row)-.5)*2.;\n}',
    number: common + '\nvec3 getElements(sampler2D tex, vec2 coord) {\n    highp vec4 value = texture2D(tex, coord);\n    highp float uint = (value.x*255.)+(value.y*65025.)+(value.z*16581375.);\n    float press = ceil(value.a*255.)-244.;\n    return vec3(uint, abs(press), sign(press));\n}\nfloat getNumber(sampler2D tex, vec2 res, float col, float row) {\n    vec2 coord = getCoord(res, col, row);\n    highp vec3 elements = getElements(tex, coord);\n    return elements.x * pow(10.,-floor(elements.y)) * elements.z;\n}' + '\n',
    position: position,
    color: color,
    vec2: position,
    vec3: color,
    vec4: color
};

function getDecodeFunctionFor(type) {
    return decode[type];
}

window.getDecodeFunctionFor = getDecodeFunctionFor;

},{"./encode":21}],21:[function(require,module,exports){
'use strict';

var _Math$sign = require('babel-runtime/core-js/math/sign')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.getRangeFor = getRangeFor;
exports.encodeValue = encodeValue;

var _common = require('./common');

// Default Ranges
var ranges = {
	number: [-16581375, 16581375],
	char: [-128, 127],
	uchar: [0, 255],
	int: [-8290688, 8290687],
	uint: [0, 16581375],
	float: [-1, 1],
	ufloat: [0, 1],
	color: [0, 255],
	rgb: [0, 255],
	position: [-1, 1],
	vec2: [-1, 1],
	vec3: [-1, 1],
	vec4: [-1, 1]
};

function getRangeFor(type) {
	return ranges[type];
}

function clampValue(value, range) {
	if (value < range[0] || value > range[1]) {
		console.warn('Value', value, 'is out of range', range, 'will be clamped to', (0, _common.clamp)(value, range[0], range[1]));
		return (0, _common.clamp)(value, range[0], range[1]);
	} else {
		return value;
	}
}

function normalizeValue(value, range) {
	return (0, _common.map)(value, range[0], range[1], 0, 1);
}

function encodeValue(value, type, range) {
	if (!range) {
		range = getRangeFor(type);
	}

	if (typeof value === 'number') {
		value = clampValue(value, range);
		if (type !== 'number') {
			// "Number" type don't need normaliztion because tries to set the presition dinamically
			value = normalizeValue(value, range);
		}
	} else if (Array.isArray(value)) {
		for (var i in value) {
			value[i] = clampValue(value[i], range);
			if (type !== 'number') {
				// "Number" type don't need normaliztion because tries to set the presition dinamically
				value[i] = normalizeValue(value[i], range);
			}
		}
	} else {
		console.log('Value type could not be read', value, type, range);
		return;
	}

	if (type === 'uchar' || type === 'char') {
		value *= 255;
		return [Math.floor(value), Math.floor(value), Math.floor(value), 255];
	} else if (type === 'int' || type === 'uint' || type === 'float' || type === 'ufloat') {
		value = value * 16581375;
		return [Math.floor(value % 255), Math.floor(value / 255) % 255, Math.floor(value / (255 * 255)), 255];
	} else if (type === 'number') {
		var s = _Math$sign(value);
		var d = (0, _common.decimals)(value) + 1.;
		var uint = Math.abs(value) * Math.pow(10, d); // transform the number into unsigned integers
		var pres = 244 + d * s;
		// console.log("Value:",value,"S:",s,"D:",d,"Uint:",uint,"Press:",pres);
		return [Math.floor(uint % 255), Math.floor(uint / 255) % 255, Math.floor(uint / (255 * 255)), pres];
	} else if (type === 'position' || type === 'vec2') {
		var x = value[0] * 65025;
		var y = value[1] * 65025;
		return [Math.floor(x % 255), Math.floor(x / 255) % 255, Math.floor(y % 255), Math.floor(y / 255) % 255];
	} else if (type === 'color' || type === 'rgb' || type === 'vec3' || type === 'vec4') {
		return [Math.floor(value[0] * 255), Math.floor(value[1] * 255), Math.floor(value[2] * 255), value[3] ? Math.floor(value[3] * 255) : 255];
	}
}

window.getRangeFor = getRangeFor;

},{"./common":19,"babel-runtime/core-js/math/sign":1}]},{},[18])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hdGgvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2Vwc2lsb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzLWNhbGwtY2hlY2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZS1jbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWF0aC9zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvZXBzaWxvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmEtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5tYXRoLXNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCIvVXNlcnMvcGF0cmljaW8vRGVza3RvcC9kYXRhMmltYWdlL3NyYy9EYXRhMkltYWdlLmpzIiwiL1VzZXJzL3BhdHJpY2lvL0Rlc2t0b3AvZGF0YTJpbWFnZS9zcmMvY29tbW9uLmpzIiwiL1VzZXJzL3BhdHJpY2lvL0Rlc2t0b3AvZGF0YTJpbWFnZS9zcmMvZGVjb2RlLmpzIiwiL1VzZXJzL3BhdHJpY2lvL0Rlc2t0b3AvZGF0YTJpbWFnZS9zcmMvZW5jb2RlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0VBQ0wsTUFDSSxJQUFJLElBQUksS0FBSyxPQUFPLElBQUksSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxNQUFNLEVBQUU7QUFDbEYsU0FBTyxDQUNBLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxFQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBQyxHQUFHLENBQUMsRUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUMsR0FBRyxDQUFDLEVBQ3hCLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBQyxHQUFHLENBQUMsR0FBRSxHQUFHLENBQzNDLENBQUM7RUFDTDtDQUNEOztBQUVELE1BQU0sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXRoL3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2Vwc2lsb25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKVtcImRlZmF1bHRcIl07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG5cbiAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0pKCk7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuTWF0aC5zaWduOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgucG93KDIsIC01Mik7IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkLnNldERlc2MoaXQsIGtleSwgZGVzYyk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzEuMi42J307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiBrZXkgaW4gdGFyZ2V0O1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihwYXJhbSl7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQyA/IG5ldyBDKHBhcmFtKSA6IEMocGFyYW0pO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICBpZihJU19QUk9UTykoZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSkpW2tleV0gPSBvdXQ7XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7IC8vIHdyYXBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyICRPYmplY3QgPSBPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiAgICAgJE9iamVjdC5jcmVhdGUsXG4gIGdldFByb3RvOiAgICRPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gIGlzRW51bTogICAgIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICBnZXREZXNjOiAgICAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgc2V0RGVzYzogICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgc2V0RGVzY3M6ICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuICBnZXRLZXlzOiAgICAkT2JqZWN0LmtleXMsXG4gIGdldE5hbWVzOiAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgZ2V0U3ltYm9sczogJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gIGVhY2g6ICAgICAgIFtdLmZvckVhY2hcbn07IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge3NpZ246IHJlcXVpcmUoJy4vJC5tYXRoLXNpZ24nKX0pOyIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7RVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKX0pOyIsIlxuaW1wb3J0IHsgZW5jb2RlVmFsdWUgfSBmcm9tICcuL2VuY29kZSc7XG5pbXBvcnQgeyBnZXREZWNvZGVGdW5jdGlvbkZvciB9IGZyb20gJy4vZGVjb2RlJztcblxuLy8gQ2xhc3NcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGEySW1hZ2Uge1xuXHRjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xuXHRcdHRoaXMuaW5zdGFuY2VzID0gMDtcblx0fVxuXG5cdGFkZEVsZW1lbnQgKG5hbWUsIHR5cGUsIHBvcHVsYXRlX2NhbGxiYWNrLCByYW5nZSkge1xuXHRcdHRoaXMuZWxlbWVudHMucHVzaCh7IGlkOiB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgbmFtZTogbmFtZSwgdHlwZTogdHlwZSwgcmFuZ2U6IHJhbmdlLCBmaWxsOiBwb3B1bGF0ZV9jYWxsYmFjayB9KTtcblx0fVxuXG5cdGdldFRvdGFsRWxlbWVudHMgKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0fVxuXG5cdHNldFRvdGFsSW5zdGFuY2VzIChudW1iZXIpIHtcblx0XHR0aGlzLmluc3RhbmNlcyA9IG51bWJlcjtcblx0fVxuXG5cdGdldFRvdGFsSW5zdGFuY2VzICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZXM7XG5cdH1cblxuXHRnZXRUYWJsZVNpemUgKCkge1xuXHRcdHJldHVybiBbdGhpcy5nZXRUb3RhbEluc3RhbmNlcygpLCB0aGlzLmdldFRvdGFsRWxlbWVudHMoKV07XG5cdH1cblxuXHRnZW5lcmF0ZSAoKSB7XG5cdFx0bGV0IHdpZHRoID0gdGhpcy5nZXRUb3RhbEluc3RhbmNlcygpO1xuXHRcdGxldCBoZWlnaHQgPSB0aGlzLmdldFRvdGFsRWxlbWVudHMoKTtcblxuXHRcdGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHQgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG5cdCAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0bGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHQgICAgbGV0IGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cdCAgICBsZXQgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHQgICAgbGV0IGluZGV4LCB5LCB4LCByLCBpO1x0ICAgIFx0XG5cdCAgICBsZXQgY2hhbm5lbHMgPSA0O1xuXHQgICAgbGV0IHZhbHVlO1xuXG5cdCAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcblx0ICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuXHQgICAgICAgICAgICBpbmRleCA9ICh5KndpZHRoK3gpKmNoYW5uZWxzO1xuXHQgICAgICAgICAgICBsZXQgdiA9IHRoaXMuZWxlbWVudHNbeV0uZmlsbCh4LCB0aGlzLmVsZW1lbnRzW3ldKTtcblx0XHRcdFx0dmFsdWUgPSBlbmNvZGVWYWx1ZSh2LCB0aGlzLmVsZW1lbnRzW3ldLnR5cGUsIHRoaXMuZWxlbWVudHNbeV0ucmFuZ2UpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaW5kZXgraV0gPSB2YWx1ZVtpXTtcblx0XHRcdFx0fVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblx0ICAgIHJldHVybiBjYW52YXM7XG5cdH1cblxuXHR2ZXJzaW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcwLjAuMic7XG4gICAgfVxufVxuXG53aW5kb3cuRGF0YTJJbWFnZSA9IERhdGEySW1hZ2U7IiwiZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuXHQvLyByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7IC8vIGZhc3Rlcj8/XG5cdHJldHVybiAodmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcCh2YWx1ZSwgaW5wdXRNaW4sIGlucHV0TWF4LCBvdXRwdXRNaW4sIG91dHB1dE1heCwgY2xhbXAgPSB0cnVlICkge1xuICAgIGlmIChNYXRoLmFicyhpbnB1dE1pbiAtIGlucHV0TWF4KSA8IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRNaW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dFZhbCA9ICgodmFsdWUgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbikgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbik7XG4gICAgICAgIGlmIChjbGFtcCkge1xuICAgICAgICAgICAgaWYgKG91dHB1dE1heCA8IG91dHB1dE1pbikge1xuICAgICAgICAgICAgICAgIGlmIChvdXRWYWwgPCBvdXRwdXRNYXgpIHtcbiAgICAgICAgICAgICAgICBcdG91dFZhbCA9IG91dHB1dE1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiggb3V0VmFsID4gb3V0cHV0TWluICkge1xuICAgICAgICAgICAgICAgIFx0b3V0VmFsID0gb3V0cHV0TWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0VmFsID4gb3V0cHV0TWF4KSB7XG4gICAgICAgICAgICAgICAgXHRvdXRWYWwgPSBvdXRwdXRNYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoIG91dFZhbCA8IG91dHB1dE1pbiApIHtcbiAgICAgICAgICAgICAgICBcdG91dFZhbCA9IG91dHB1dE1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dFZhbDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNpbWFscyhudW1iZXIpIHtcblx0bGV0IG1hdGNoID0gKE1hdGguYWJzKG51bWJlcikgKyAnJykubWF0Y2goL1xcZCtcXC4oXFxkKykvKTtcblx0cmV0dXJuIG1hdGNoPyBtYXRjaFsxXS5sZW5ndGggOiAwO1xufSIsImltcG9ydCB7IGdldFJhbmdlRm9yIH0gZnJvbSAnLi9lbmNvZGUnO1xuXG52YXIgY29tbW9uID0gYFxudmVjMiBnZXRDb29yZCh2ZWMyIHJlcywgZmxvYXQgY29sLCBmbG9hdCByb3cpIHtcbiAgICByZXR1cm4gZnJhY3QodmVjMihjb2wscm93Ky41KS9yZXMpO1xufWArJ1xcbic7XG5cbnZhciB1aW50ID0gY29tbW9uICsgYFxuZmxvYXQgZ2V0VUludChzYW1wbGVyMkQgdGV4LCB2ZWMyIHJlcywgZmxvYXQgY29sLCBmbG9hdCByb3cpIHtcbiAgICBoaWdocCB2ZWM0IHZhbHVlID0gdGV4dHVyZTJEKHRleCwgY29vcmQpO1xuICAgIHJldHVybiAodmFsdWUueCoyNTUuKSsodmFsdWUueSo2NTAyNS4pKyh2YWx1ZS56KjE2NTgxMzc1Lik7XG59YDtcblxudmFyIHVmbG9hdCA9IGNvbW1vbiArIGBcbmZsb2F0IGdldFVGbG9hdChzYW1wbGVyMkQgdGV4LCB2ZWMyIHJlcywgZmxvYXQgY29sLCBmbG9hdCByb3cpIHtcbiAgICBoaWdocCB2ZWM0IHZhbHVlID0gdGV4dHVyZTJEKHRleCwgY29vcmQpO1xuICAgIHJldHVybiAoKHZhbHVlLngqMjU1LikrKHZhbHVlLnkqNjUwMjUuKSsodmFsdWUueioxNjU4MTM3NS4pKS8xNjU4MTM3NS47XG59YDtcblxudmFyIHBvc2l0aW9uID0gY29tbW9uICsgYFxudmVjMiBnZXRQb3NpdGlvbihzYW1wbGVyMkQgdGV4LCB2ZWMyIHJlcywgZmxvYXQgY29sLCBmbG9hdCByb3cpIHtcbiAgICB2ZWMyIGNvb3JkID0gZ2V0Q29vcmQocmVzLCBjb2wsIHJvdyk7XG4gICAgaGlnaHAgdmVjNCB2YWx1ZSA9IHRleHR1cmUyRCh0ZXgsIGNvb3JkKTtcbiAgICBmbG9hdCB4ID0gKHZhbHVlLnIqMjU1K3ZhbHVlLmcqNjUwMjUuKS82NTAyNS47XG4gICAgZmxvYXQgeSA9ICh2YWx1ZS5iKjI1NS4rdmFsdWUuYSo2NTAyNS4pLzY1MDI1LjtcbiAgICByZXR1cm4gdmVjMih4LHkpO1xufWArJ1xcbic7XG5cbnZhciBjb2xvciA9IGNvbW1vbiArIGBcbnZlYzQgZ2V0Q29sb3Ioc2FtcGxlcjJEIHRleCwgdmVjMiByZXMsIGZsb2F0IGNvbCwgZmxvYXQgcm93KSB7XG4gICAgdmVjMiBjb29yZCA9IGdldENvb3JkKHJlcywgY29sLCByb3cpO1xuICAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCBjb29yZCk7XG59YCsnXFxuJztcblxudmFyIGRlY29kZSA9IHtcbiAgICB1aW50OiB1aW50LFxuICAgIGludDogdWludCArIGBcbmZsb2F0IGdldEludChzYW1wbGVyMkQgdGV4LCB2ZWMyIHJlcywgZmxvYXQgY29sLCBmbG9hdCByb3cpIHtcbiAgICByZXR1cm4gZ2V0VUludCh0ZXgscmVzLGNvbCxyb3cpLTgyOTA2ODguO1xufWAsXG4gICAgdWZsb2F0OiB1ZmxvYXQsXG4gICAgZmxvYXQ6IHVmbG9hdCArIGBcbmZsb2F0IGdldFVGbG9hdChzYW1wbGVyMkQgdGV4LCB2ZWMyIHJlcywgZmxvYXQgY29sLCBmbG9hdCByb3cpIHtcbiAgICByZXR1cm4gKGdldFVGbG9hdCh0ZXgscmVzLGNvbCxyb3cpLS41KSoyLjtcbn1gLFxuICAgIG51bWJlcjogY29tbW9uICsgYFxudmVjMyBnZXRFbGVtZW50cyhzYW1wbGVyMkQgdGV4LCB2ZWMyIGNvb3JkKSB7XG4gICAgaGlnaHAgdmVjNCB2YWx1ZSA9IHRleHR1cmUyRCh0ZXgsIGNvb3JkKTtcbiAgICBoaWdocCBmbG9hdCB1aW50ID0gKHZhbHVlLngqMjU1LikrKHZhbHVlLnkqNjUwMjUuKSsodmFsdWUueioxNjU4MTM3NS4pO1xuICAgIGZsb2F0IHByZXNzID0gY2VpbCh2YWx1ZS5hKjI1NS4pLTI0NC47XG4gICAgcmV0dXJuIHZlYzModWludCwgYWJzKHByZXNzKSwgc2lnbihwcmVzcykpO1xufVxuZmxvYXQgZ2V0TnVtYmVyKHNhbXBsZXIyRCB0ZXgsIHZlYzIgcmVzLCBmbG9hdCBjb2wsIGZsb2F0IHJvdykge1xuICAgIHZlYzIgY29vcmQgPSBnZXRDb29yZChyZXMsIGNvbCwgcm93KTtcbiAgICBoaWdocCB2ZWMzIGVsZW1lbnRzID0gZ2V0RWxlbWVudHModGV4LCBjb29yZCk7XG4gICAgcmV0dXJuIGVsZW1lbnRzLnggKiBwb3coMTAuLC1mbG9vcihlbGVtZW50cy55KSkgKiBlbGVtZW50cy56O1xufWArJ1xcbicsXG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIGNvbG9yOiBjb2xvcixcbiAgICB2ZWMyOiBwb3NpdGlvbixcbiAgICB2ZWMzOiBjb2xvcixcbiAgICB2ZWM0OiBjb2xvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVjb2RlRnVuY3Rpb25Gb3IgKHR5cGUpIHtcbiAgICByZXR1cm4gZGVjb2RlW3R5cGVdO1xufVxuXG53aW5kb3cuZ2V0RGVjb2RlRnVuY3Rpb25Gb3IgPSBnZXREZWNvZGVGdW5jdGlvbkZvcjsiLCJpbXBvcnQgeyBjbGFtcCwgbWFwLCBkZWNpbWFscyB9IGZyb20gJy4vY29tbW9uJztcblxuLy8gRGVmYXVsdCBSYW5nZXNcbnZhciByYW5nZXMgPSB7XG5cdG51bWJlcjogWy0xNjU4MTM3NSwxNjU4MTM3NV0sXG5cdGNoYXI6IFx0Wy0xMjgsIDEyN10sXG5cdHVjaGFyOiBcdFswLCAyNTVdLFxuXHRpbnQ6IFx0Wy04MjkwNjg4LCA4MjkwNjg3XSxcblx0dWludDogXHRbMCwgMTY1ODEzNzVdLFxuXHRmbG9hdDogXHRbLTEsIDFdLFxuXHR1ZmxvYXQ6IFswLCAxXSxcblx0Y29sb3I6IFx0WzAsIDI1NV0sXG5cdHJnYjogXHRbMCwgMjU1XSxcblx0cG9zaXRpb246IFstMSwgMV0sXG5cdHZlYzI6IFx0Wy0xLCAxXSxcblx0dmVjMzogXHRbLTEsIDFdLFxuXHR2ZWM0OiBcdFstMSwgMV1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZUZvciAodHlwZSkge1xuXHRyZXR1cm4gcmFuZ2VzW3R5cGVdO1xufVxuXG5mdW5jdGlvbiBjbGFtcFZhbHVlICh2YWx1ZSwgcmFuZ2UpIHtcblx0aWYgKHZhbHVlIDwgcmFuZ2VbMF0gfHwgdmFsdWUgPiByYW5nZVsxXSkge1xuXHRcdGNvbnNvbGUud2FybignVmFsdWUnLHZhbHVlLCdpcyBvdXQgb2YgcmFuZ2UnLHJhbmdlLCd3aWxsIGJlIGNsYW1wZWQgdG8nLCBjbGFtcCh2YWx1ZSxyYW5nZVswXSxyYW5nZVsxXSkpO1xuXHRcdHJldHVybiBjbGFtcCh2YWx1ZSxyYW5nZVswXSxyYW5nZVsxXSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlICh2YWx1ZSwgcmFuZ2UpIHtcblx0cmV0dXJuIG1hcCh2YWx1ZSxyYW5nZVswXSxyYW5nZVsxXSwwLDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlVmFsdWUgKHZhbHVlLCB0eXBlLCByYW5nZSkge1xuXHRpZiAoIXJhbmdlKSB7XG5cdFx0cmFuZ2UgPSBnZXRSYW5nZUZvcih0eXBlKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cdFx0dmFsdWUgPSBjbGFtcFZhbHVlKHZhbHVlLCByYW5nZSk7XG5cdFx0aWYgKHR5cGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBcIk51bWJlclwiIHR5cGUgZG9uJ3QgbmVlZCBub3JtYWxpenRpb24gYmVjYXVzZSB0cmllcyB0byBzZXQgdGhlIHByZXNpdGlvbiBkaW5hbWljYWxseVxuXHRcdFx0dmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSwgcmFuZ2UpO1xuXHRcdH1cblx0fSBcblx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRmb3IgKGxldCBpIGluIHZhbHVlKSB7XG5cdFx0XHR2YWx1ZVtpXSA9IGNsYW1wVmFsdWUodmFsdWVbaV0sIHJhbmdlKTtcblx0XHRcdGlmICh0eXBlICE9PSAnbnVtYmVyJykge1xuXHRcdFx0XHQvLyBcIk51bWJlclwiIHR5cGUgZG9uJ3QgbmVlZCBub3JtYWxpenRpb24gYmVjYXVzZSB0cmllcyB0byBzZXQgdGhlIHByZXNpdGlvbiBkaW5hbWljYWxseVxuXHRcdFx0XHR2YWx1ZVtpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlW2ldLCByYW5nZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IFxuXHRlbHNlIHtcblx0XHRjb25zb2xlLmxvZygnVmFsdWUgdHlwZSBjb3VsZCBub3QgYmUgcmVhZCcsIHZhbHVlLCB0eXBlLCByYW5nZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdFxuXHRpZiAodHlwZSA9PT0gJ3VjaGFyJyB8fCB0eXBlID09PSAnY2hhcicpIHtcblx0XHR2YWx1ZSAqPSAyNTU7XG5cdCAgICByZXR1cm4gW1xuXHQgICAgICAgIE1hdGguZmxvb3IodmFsdWUpLFxuXHQgICAgICAgIE1hdGguZmxvb3IodmFsdWUpLFxuXHQgICAgICAgIE1hdGguZmxvb3IodmFsdWUpLFxuXHQgICAgICAgIDI1NVxuXHQgICAgXTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnaW50JyB8fCB0eXBlID09PSAndWludCcgIHx8IHR5cGUgPT09ICdmbG9hdCcgfHwgdHlwZSA9PT0gJ3VmbG9hdCcpIHtcblx0XHR2YWx1ZSA9IHZhbHVlKjE2NTgxMzc1O1xuXHQgICAgcmV0dXJuIFtcblx0ICAgICAgICBNYXRoLmZsb29yKHZhbHVlJTI1NSksXG5cdCAgICAgICAgTWF0aC5mbG9vcih2YWx1ZS8yNTUpJTI1NSxcblx0ICAgICAgICBNYXRoLmZsb29yKHZhbHVlLygyNTUqMjU1KSksXG5cdCAgICAgICAgMjU1XG5cdCAgICBdO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0bGV0IHMgPSBNYXRoLnNpZ24odmFsdWUpO1xuXHRcdGxldCBkID0gZGVjaW1hbHModmFsdWUpKzEuO1xuXHRcdGxldCB1aW50ID0gTWF0aC5hYnModmFsdWUpICogTWF0aC5wb3coMTAsZCk7XHQvLyB0cmFuc2Zvcm0gdGhlIG51bWJlciBpbnRvIHVuc2lnbmVkIGludGVnZXJzXG5cdFx0bGV0IHByZXMgPSAyNDQgKyBkKnM7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJWYWx1ZTpcIix2YWx1ZSxcIlM6XCIscyxcIkQ6XCIsZCxcIlVpbnQ6XCIsdWludCxcIlByZXNzOlwiLHByZXMpO1xuXHQgICAgcmV0dXJuIFtcblx0ICAgICAgICBNYXRoLmZsb29yKHVpbnQlMjU1KSxcblx0ICAgICAgICBNYXRoLmZsb29yKHVpbnQvMjU1KSUyNTUsXG5cdCAgICAgICAgTWF0aC5mbG9vcih1aW50LygyNTUqMjU1KSksXG5cdCAgICAgICAgcHJlc1xuXHQgICAgXTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAncG9zaXRpb24nIHx8IHR5cGUgPT09ICd2ZWMyJykge1x0XHRcdFx0XG5cdFx0bGV0IHggPSB2YWx1ZVswXSo2NTAyNTtcblx0XHRsZXQgeSA9IHZhbHVlWzFdKjY1MDI1O1xuXHRcdHJldHVybiBbXG5cdFx0XHRNYXRoLmZsb29yKHglMjU1KSxcblx0ICAgICAgICBNYXRoLmZsb29yKHgvMjU1KSUyNTUsXG5cdCAgICAgICAgTWF0aC5mbG9vcih5JTI1NSksXG5cdCAgICAgICAgTWF0aC5mbG9vcih5LzI1NSklMjU1XG5cdCAgICBdO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdjb2xvcicgfHwgdHlwZSA9PT0gJ3JnYicgfHwgdHlwZSA9PT0gJ3ZlYzMnIHx8IHR5cGUgPT09ICd2ZWM0Jykge1xuXHRcdHJldHVybiBbXG5cdCAgICAgICAgTWF0aC5mbG9vcih2YWx1ZVswXSoyNTUpLFxuXHQgICAgICAgIE1hdGguZmxvb3IodmFsdWVbMV0qMjU1KSxcblx0ICAgICAgICBNYXRoLmZsb29yKHZhbHVlWzJdKjI1NSksXG5cdCAgICAgICAgdmFsdWVbM10gPyBNYXRoLmZsb29yKHZhbHVlWzNdKjI1NSk6IDI1NVxuXHQgICAgXTtcblx0fVxufVxuXG53aW5kb3cuZ2V0UmFuZ2VGb3IgPSBnZXRSYW5nZUZvcjsiXX0=
